= 5. Data Types
:sectanchors:
:source-highlighter: pygments

== 5.1 Basic data types
In Kotlin, we have several basic data types such as `Int`, `Double`, `String`, and `Boolean`. We can use these data types to define the properties of our classes.

=== 5.1.1 Use basic data types
First, let's update our `Race` class. In the `Race` class, add a constructor with the immutable property `numberOfLaps: Int`, representing the number of laps in this race, and a mutable property `currentLap: Int` to indicate the current lap of the race:


[source,kotlin]
----
class Race(
    val numberOfLaps: Int,
    var currentLap: Int = 0,
)
----

Then, update our `RaceCar` class. Add a nullable, immutable `manufacturer` property to the `RaceCar` class with a default value of `null`:

[source,kotlin]
----
class RaceCar (
    val carNumber: Int,
    val manufacturer: String? = null,
    val maxSpeed: Double = Random.nextDouble(200.0, 230.0),
    private var currentSpeed: Double = 0.0,
    internal var currentLap: Int = 0,
    internal var isPitStopNeeded: Boolean = false,
    numLaps: Int,
)
----

=== 5.1.2 Use basic operators

Next, open the Driver class and add a function `addPoints(newPoints: Int)` that adds points to the driver. Here, `newPoints` is of type `Int`, which signifies the number of points to be added:

[source,kotlin]
----
fun addPoints(newPoints: Int) {
    points += newPoints
}
----

=== 5.1.3 Experimenting with Basic Data Types
In your IDE, locate the Scratch file, which should be in the *Scratches and Consoles* > *Scratches*. Clear an existing Scratch file or create a new Scratch file.

Declare variables of each basic data type:

[source,kotlin]
----
val numberOfLaps: Int = 10
val currentLap: Int = 0
val newPoints: Int = 5
val manufacturer: String? = "Manufacturer X"
----

Now create an instance of Race and Driver using these variables

[source,kotlin]
----
val race = Race(numberOfLaps, currentLap)
val driver = Driver()
val raceCar = RaceCar(1, manufacturer)
----

Use the addPoints function to add points to the driver and print the updated points:

[source,kotlin]
----
driver.addPoints(newPoints)
println(driver.points)
----

Increment the currentLap of the Race instance and print it:

[source,kotlin]
----
race.currentLap++
println("The race is now in lap: ${race.currentLap}")
----

Try adding a condition to check if the race has ended (when current lap is equal to the total number of laps):

[source,kotlin]
----
if(race.currentLap == race.numberOfLaps) {
    println("The race has ended.")
} else {
    println("The race is still on.")
}
----

Print the RaceCar instance's manufacturer:

[source,kotlin]
----
println("The race car's manufacturer is: ${raceCar.manufacturer}")
----

Run the scratch file and observe how the variables and functions using basic data types work.

== 5.2 Collections
In Kotlin, collections such as lists, sets, and maps play a significant role in handling and manipulating data. They allow us to store multiple items in a single variable. Let's see how we can use them in our project.

=== 5.2.1 Update F1 Simulator application

Firstly, create a new class `Team` in the `participants` package. This class will have an immutable `name: String`, and two immutable collections - a list of drivers `drivers: List<Driver>`, and a set of race cars `raceCars: Set<RaceCar>`:

[source,kotlin]
----
class Team(
    val name: String,
    val drivers: List<Driver>,
    val raceCars: Set<RaceCar>,
) {

}
----

Then, we'll create a map that assigns each driver to a race car. Add an immutable `driverCarMap: Map<Driver, RaceCar>` property, which can be initialized by zipping together the drivers list and the raceCars set, and then converting the resultant pairs to a map:

[source,kotlin]
----
class Team(
    val name: String,
    val drivers: List<Driver>,
    val raceCars: Set<RaceCar>,
) {
    val driverCarMap: Map<Driver, RaceCar> = drivers.zip(raceCars).toMap()
}
----

Finally, to the `Race` class, add an immutable list of teams `teams: List<Team>` to the primary constructor:

[source,kotlin]
----
class Race(
    val numberOfLaps: Int,
    val teams: List<Team>,
    var currentLap: Int = 0,
) {

}
----

Now, we can represent a team of drivers, each with their own race car, and multiple teams can participate in a race.

=== 5.2.1 Try them in Scratch file
In your IDE, locate the Scratch file, which should be in the *Scratches and Consoles* > *Scratches*. Clear an existing Scratch file or create a new Scratch file.

Create a few instances of `Driver`, `RaceCar`, and `Team`:

[source,kotlin]
----
// Create a few instances of Driver, RaceCar
val driver1 = Driver("Driver 1", 0)
val driver2 = Driver("Driver 2", 10)
val driver3 = Driver("Driver 3", 20)

val car1 = RaceCar(carNumber = 1, manufacturer = "Manufacturer 1", numLaps = 6)
val car2 = RaceCar(carNumber = 2, manufacturer = "Manufacturer 2", numLaps = 6)
val car3 = RaceCar(carNumber = 3, manufacturer = "Manufacturer 3", numLaps = 6)

// Create a team
val team1 = Team("Team 1", listOf(driver1, driver2), setOf(car1, car2))
val team2 = Team("Team 2", listOf(driver3), setOf(car3))

----

Try accessing elements of drivers, raceCars, and teams using indices or keys.

[source,kotlin]
----
println(team1.drivers[0])  // Accessing the first driver in Team 1
println(team1.raceCars.first())  // Accessing the first car in Team 1
println(team1.driverCarMap[driver1])  // Accessing the car for driver1 in Team 1
----

Use `forEach` and `forEachIndexed` to iterate over the collections and print out some information about each element.

[source,kotlin]
----
team1.drivers.forEach { driver -> println(driver.name) }
team1.raceCars.forEachIndexed { index, car -> println("Car $index: ${car.name}") }
----

Use `find` to search for a specific element in a collection.

[source,kotlin]
----
val foundDriver = team1.drivers.find { it.name == "Driver 1" }
println(foundDriver)
----

Use `filter` to create a new collection that only contains elements that meet certain conditions.

[source,kotlin]
----
val experiencedDrivers = team1.drivers.filter { it.points > 0 }
println(experiencedDrivers)
----

Use `sumOf` to calculate the sum of a certain property of all elements in a collection.

[source,kotlin]
----
val totalPoints = team1.drivers.sumOf { it.points }
println(totalPoints)
----

Use `sortedBy`  and `sortedByDescending` to sort the collections by a certain property.

[source,kotlin]
----
val sortedByPoints = team1.drivers.sortedBy { it.points }
println(sortedByPoints)

val sortedByPointsDesc = team1.drivers.sortedByDescending { it.points }
println(sortedByPointsDesc)
----

Use `map` to transform all elements in a collection

[source,kotlin]
----
val driverNames = team1.drivers.map { it.name }
println(driverNames)
----

Notice how object references are printed instead of something meaningful. Let's improve this in the next section. Keep the Scratch file contents as we shall use it in the next section.

== 5.3 Custom data types

=== 5.3.1 Classes
Classes in Kotlin allow us to create custom data types with their own properties and behaviors.

Start by improving the `toString` method in the `Driver` class to provide a better representation of the object. This method should return a `String` representation of the `Driver` instance. Generate `toString` in the `Driver` class including `name` and `points` properties. You can do this by right-clicking inside the `Driver` class, then choosing *Generate*, selecting *toString*, then *name* and *points*, and clicking *OK*.

[source,kotlin]
----
override fun toString(): String {
    return "Driver(name='$name', points=$points)"
}
----

Run the scratch file again from the previous exercise. Do you see the difference? Now, when you print a `Driver` instance, you should see the driver's name and points instead of the object reference.

To compare two `Driver` instances effectively, override `equals` and `hashCode` in the `Driver` class. This process can be automated in your IDE. Right-click inside the `Driver` class, choose *Generate*, select *equals* and *hashCode*, then *uuid*, and click *OK*. This operation will generate `equals` and `hashCode` methods so that two `Driver` instances with the same `uuid` are considered equal:

[source,kotlin]
----
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as Driver

        if (uuid != other.uuid) return false

        return true
    }

    override fun hashCode(): Int {
        return uuid.hashCode()
    }
----

Let's also enhance the `toString` method for the `RaceCar` and `Team` classes. Repeat the generation process for these classes but this time only select the `toString` method. We will keep the default implementation of `equals` and `hashCode` from the `Any` class for these classes.

After enhancing the `toString` method in our classes, the outputs when printing instances of `Team`, `RaceCar`, and `Driver` should now appear in a more human-readable format.

To observe the changes, rerun the scratch file from the previous exercise. Pay special attention to how the `Team` and `RaceCar` instances are printed. Now, instead of seeing obscure object references, you should be able to see informative descriptions of each instance, making the results of the operations on collections much easier to understand.

Try comparing two drivers with the same UUID and observe the result:

[source,kotlin]
----
val driverJohn = Driver("John Doe", 100)
val driverJane = Driver("Jane Doe", 100, driverJohn.uuid)
println(driverJohn == driverJane) // should print 'true'
----

== 5.3.2 Data Classes
In Kotlin, we have a special kind of classes called data classes, which are mainly used to hold data. In data classes, standard functions like `toString`, `equals`, `hashCode`, and the copying mechanism are automatically generated, which can be very convenient.

==== 5.3.2.1 Update F1 app
For our F1 app, we can add a data class `Result` inside our `Race` class to represent the result of each driver, team, and race car. We also keep track of the race's progress with a mutable list of `raceResults`.

[source,kotlin]
----
import com.example.f1app.participants.Driver
import com.example.f1app.participants.RaceCar
import com.example.f1app.participants.Team

class Race(
    val numberOfLaps: Int,
    val teams: List<Team>,
    var currentLap: Int = 0,
) {
    private val raceResults: MutableList<Result> = mutableListOf()

    data class Result(
        val team: Team,
        val driver: Driver,
        val car: RaceCar,
        var totalLapTime: Double = 0.0,
        var fastestLap: Double = Double.MAX_VALUE,
    )

    companion object {
        const val PITSTOP_TIME = 5.0 // 5 minutes
    }
}
----

==== 5.3.2.1 Experimenting with Data Classes
Now, let's try to understand how data classes work using the Scratch file (clear existing Scratch file or create a new Scratch file).

Create instances of Driver, RaceCar, Team, and Race:

[source,kotlin]
----
val driver = Driver("Hamilton")
val raceCar = RaceCar(carNumber = 44)
val team = Team("Mercedes", listOf(driver), setOf(raceCar))
val race = Race(56, listOf(team))
----


=== 5.3.3 Enum Classes

In Kotlin, Enum Classes are used to create a type which can have a fixed number of possible instances. For our F1 app, we can create an Enum Class RaceEvent to represent different events that can happen during a race such as normal lap, breakdown or collision.

Place this `RaceEvent` Enum Class as a top-level declaration after the `Race` class in *Race.kt*:


[source,kotlin]
----
enum class RaceEvent {
    NORMAL,
    BREAKDOWN,
    COLLISION,
}
----

After defining our RaceEvent Enum Class, let's use it in our Scratch file (clear existing Scratch file or create a new Scratch file).

Declare a variable raceEvent of type RaceEvent and assign it a value of RaceEvent.NORMAL. Print it:

[source,kotlin]
----
import com.example.f1app.RaceEvent

var raceEvent: RaceEvent = RaceEvent.NORMAL
println("Current Race Event: $raceEvent")
----

Simulate a change in race event by assigning `RaceEvent.BREAKDOWN` to `raceEvent` and print it:

[source,kotlin]
----
raceEvent = RaceEvent.BREAKDOWN
println("Current Race Event: $raceEvent")
----

Enum classes have built-in methods to list all constants (`values()`) and find a constant by its name (`valueOf(name: String)`). Try these methods and observe the outputs:

[source,kotlin]
----
val allEvents = RaceEvent.values()
println("All possible Race Events: ${allEvents.joinToString(", ")}")

val collisionEvent = RaceEvent.valueOf("COLLISION")
println("Event found by name: $collisionEvent")

----

➡️ link:./6-string-templates.adoc[6. String Templates]

⬅️ link:./4-constants.adoc[4. Constants]
